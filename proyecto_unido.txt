Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:
darkanddarker/
    .gitignore
    app.py
    proyecto_unido.txt
    unir_proyecto.py
assets/
    styles.css
callbacks/
    callbacks.py
    __init__.py
components/
    layout.py
    __init__.py
data/
    class_stats.py
    weapon_stats.py
    __init__.py
models/
    character.py
    __init__.py

Contenido de los archivos:

.gitignore

/dnd/

---
app.py

# app.py

from dash import Dash
import dash_bootstrap_components as dbc
from components import create_layout
from callbacks import register_callbacks

app = Dash(__name__, external_stylesheets=[dbc.themes.BOOTSTRAP])

# Establecer el layout
app.layout = create_layout(app)

# Registrar los callbacks
register_callbacks(app)

if __name__ == '__main__':
    app.run_server(debug=True)


---
proyecto_unido.txt

Árbol de directorios:


Contenido de los archivos:



---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        '__pycache__',
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---

---
unir_proyecto.py

import os

def generate_directory_tree(root_dir, ignore_dirs):
    tree_lines = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        level = rel_dirpath.count(os.sep)
        indent = '    ' * level
        tree_lines.append(f"{indent}{os.path.basename(dirpath)}/")
        subindent = '    ' * (level + 1)
        for f in filenames:
            tree_lines.append(f"{subindent}{f}")
    return '\n'.join(tree_lines)

def collect_files(root_dir, ignore_dirs):
    files_content = []
    for dirpath, dirnames, filenames in os.walk(root_dir):
        # Convertir dirpath a ruta relativa
        rel_dirpath = os.path.relpath(dirpath, root_dir)

        # Normalizar las rutas en dirnames
        dirnames[:] = [d for d in dirnames if os.path.normpath(os.path.join(rel_dirpath, d)) not in ignore_dirs]

        # Ignorar archivos en directorios a ignorar
        if os.path.normpath(rel_dirpath) in ignore_dirs and rel_dirpath != '.':
            continue

        for filename in filenames:
            filepath = os.path.join(dirpath, filename)
            relative_path = os.path.relpath(filepath, root_dir)
            try:
                with open(filepath, 'r', encoding='utf-8') as file:
                    content = file.read()
                files_content.append(f"{relative_path}\n\n{content}\n\n---")
            except Exception as e:
                print(f"No se pudo leer el archivo {filepath}: {e}")
    return '\n'.join(files_content)

def main():
    # Reemplaza con la ruta de tu proyecto, utilizando una cadena raw
    root_dir = r'D:\vscode\paridas\darkanddarker'  

    # Lista de carpetas a ignorar, con rutas relativas y utilizando barras diagonales
    ignore_dirs = [
        'callbacks/__pycache__',
        'components/__pycache__',
        'data/__pycache__',
        'models/__pycache__',
        'dnd',
        '.git'
    ]

    # Normalizar las rutas en ignore_dirs
    ignore_dirs = [os.path.normpath(path) for path in ignore_dirs]

    # Generar el árbol de directorios
    directory_tree = generate_directory_tree(root_dir, ignore_dirs)

    # Recopilar el contenido de los archivos
    files_content = collect_files(root_dir, ignore_dirs)

    # Combinar todo en un solo archivo de texto
    with open('proyecto_unido.txt', 'w', encoding='utf-8') as output_file:
        output_file.write("Árbol de directorios:\n")
        output_file.write(directory_tree)
        output_file.write("\n\nContenido de los archivos:\n\n")
        output_file.write(files_content)

if __name__ == "__main__":
    main()


---
assets\styles.css



---
callbacks\callbacks.py

# callbacks/callbacks.py

from dash.dependencies import Input, Output, State, ALL
from dash import html, dcc
import plotly.graph_objs as go
from models.character import CharacterStats
from data.class_stats import class_stats
from data.weapon_stats import weapon_stats
import dash_bootstrap_components as dbc

def register_callbacks(app):

    @app.callback(
        [
            Output('weapon1_left', 'options'),
            Output('weapon1_right', 'options'),
            Output('weapon2_left', 'options'),
            Output('weapon2_right', 'options'),
            Output('weapon1_left', 'disabled'),
            Output('weapon1_right', 'disabled'),
            Output('weapon2_left', 'disabled'),
            Output('weapon2_right', 'disabled'),
            Output('stats-table', 'data'),
            Output('movement-table', 'data'),
            Output('defense-table', 'data'),
            Output('utility-table', 'data'),
            Output('grafica-vm', 'figure'),
            Output('output-vm-total', 'children'),
            Output('output-porcentaje-vm', 'children'),
            Output('output-mejora-optima', 'children'),
            Output('primary_combo', 'children'),
        ],
        [
            Input('input-clase', 'value'),
            Input('stats-table', 'data'),
            Input('movement-table', 'data'),
            Input('weapon1_left', 'value'),
            Input('weapon1_right', 'value'),
            Input('weapon2_left', 'value'),
            Input('weapon2_right', 'value'),
            Input('combat_type', 'value'),
            Input('show_headshot', 'value'),
            Input('combination_select', 'value'),
        ],
    )
    def actualizar_estadisticas(
        clase_seleccionada, stats_rows, movement_rows,
        weapon1_left, weapon1_right, weapon2_left, weapon2_right,
        combat_type, show_headshot, combination_select,
    ):
        # Obtener los atributos base de la clase seleccionada
        atributos_base = class_stats[clase_seleccionada]
        
        # Inicializar encantamientos
        add_stats = {}
        
        # Procesar stats_table
        if not stats_rows:
            stats_rows = [
                {'Estadística': 'Fuerza', 'Valor': atributos_base['Strength'], 'Add': 0},
                {'Estadística': 'Vigor', 'Valor': atributos_base['Vigor'], 'Add': 0},
                {'Estadística': 'Agilidad', 'Valor': atributos_base['Agility'], 'Add': 0},
                {'Estadística': 'Destreza', 'Valor': atributos_base['Dexterity'], 'Add': 0},
                {'Estadística': 'Voluntad', 'Valor': atributos_base['Will'], 'Add': 0},
                {'Estadística': 'Conocimiento', 'Valor': atributos_base['Knowledge'], 'Add': 0},
                {'Estadística': 'Ingenio', 'Valor': atributos_base['Resourcefulness'], 'Add': 0},
            ]
        else:
            for row in stats_rows:
                stat_name = row['Estadística']
                add_value = float(row['Add']) if row['Add'] else 0
                add_stats[stat_name] = add_value
        
        # Procesar movement_table
        movement_add = 0
        movement_bonus = 0
        peso_arma = 0
        peso_armadura = 0

        if not movement_rows:
            movement_rows = [
                {'Estadística': 'Velocidad de Movimiento', 'Valor': '', 'Add': 0, 'Bonus': 0},
                {'Estadística': 'Velocidad de movimiento con arma', 'Valor': '', 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de arma', 'Valor': 0, 'Add': '', 'Bonus': ''},
                {'Estadística': 'Peso de armadura', 'Valor': 0, 'Add': '', 'Bonus': ''},
            ]
        else:
            for row in movement_rows:
                stat_name = row['Estadística']
                if stat_name == 'Velocidad de Movimiento':
                    movement_add = float(row['Add']) if row['Add'] else 0
                    movement_bonus = float(row['Bonus']) if row['Bonus'] else 0
                elif stat_name == 'Peso de armadura':
                    peso_armadura = float(row['Valor']) if row['Valor'] else 0

        # Calcular el peso de las armas seleccionadas
        weapons_selected = [weapon1_left, weapon1_right, weapon2_left, weapon2_right]
        for weapon_name in weapons_selected:
            if weapon_name:
                weapon = weapon_stats[weapon_name]
                peso_arma += weapon.get('Peso', 0)

        # Crear una instancia de CharacterStats
        character = CharacterStats(
            strength=atributos_base['Strength'],
            vigor=atributos_base['Vigor'],
            agility=atributos_base['Agility'],
            dexterity=atributos_base['Dexterity'],
            will=atributos_base['Will'],
            knowledge=atributos_base['Knowledge'],
            resourcefulness=atributos_base['Resourcefulness'],
            add_stats=add_stats,
            movement_add=movement_add,
            movement_bonus=movement_bonus,
            peso_arma=peso_arma,
            peso_armadura=peso_armadura
        )

        # Actualizar los valores en la tabla de estadísticas principales
        for row in stats_rows:
            stat_name = row['Estadística']
            if stat_name == 'Fuerza':
                row['Valor'] = character.strength
            elif stat_name == 'Vigor':
                row['Valor'] = character.vigor
            elif stat_name == 'Agilidad':
                row['Valor'] = character.agility
            elif stat_name == 'Destreza':
                row['Valor'] = character.dexterity
            elif stat_name == 'Voluntad':
                row['Valor'] = character.will
            elif stat_name == 'Conocimiento':
                row['Valor'] = character.knowledge
            elif stat_name == 'Ingenio':
                row['Valor'] = character.resourcefulness

        # Actualizar los valores en la tabla de movement
        for row in movement_rows:
            stat_name = row['Estadística']
            if stat_name == 'Velocidad de Movimiento':
                row['Valor'] = character.movement_stats['Velocidad de Movimiento']
            elif stat_name == 'Velocidad de movimiento con arma':
                row['Valor'] = character.movement_stats['Velocidad de movimiento con arma']
            elif stat_name == 'Peso de arma':
                row['Valor'] = peso_arma
            elif stat_name == 'Peso de armadura':
                row['Valor'] = peso_armadura

        # Opciones iniciales de armas
        all_weapon_options = [
            {'label': weapon['Nombre'], 'value': weapon_name}
            for weapon_name, weapon in weapon_stats.items()
        ]

        # Función auxiliar para filtrar opciones
        def filtrar_opciones(seleccion_opuesta):
            if seleccion_opuesta:
                weapon_opuesta = weapon_stats[seleccion_opuesta]
                if weapon_opuesta['Manos'] == 2:
                    return []
                else:
                    return [
                        {'label': weapon['Nombre'], 'value': weapon_name}
                        for weapon_name, weapon in weapon_stats.items()
                        if weapon['Manos'] == 1
                    ]
            else:
                return all_weapon_options

        # Combinación 1
        weapon1_left_options = filtrar_opciones(weapon1_right)
        weapon1_right_options = filtrar_opciones(weapon1_left)
        weapon1_left_disabled = False
        weapon1_right_disabled = False

        if weapon1_right:
            weapon = weapon_stats[weapon1_right]
            if weapon['Manos'] == 2:
                weapon1_left_disabled = True
        if weapon1_left:
            weapon = weapon_stats[weapon1_left]
            if weapon['Manos'] == 2:
                weapon1_right_disabled = True

        # Combinación 2
        weapon2_left_options = filtrar_opciones(weapon2_right)
        weapon2_right_options = filtrar_opciones(weapon2_left)
        weapon2_left_disabled = False
        weapon2_right_disabled = False

        if weapon2_right:
            weapon = weapon_stats[weapon2_right]
            if weapon['Manos'] == 2:
                weapon2_left_disabled = True
        if weapon2_left:
            weapon = weapon_stats[weapon2_left]
            if weapon['Manos'] == 2:
                weapon2_right_disabled = True

        # Preparar datos para las tablas de categorías
        movement_data = movement_rows
        defense_data = [{'Estadística': k, 'Valor': v} for k, v in character.defense_stats.items()]
        utility_data = [{'Estadística': k, 'Valor': v} for k, v in character.utility_stats.items()]

        # Gráfica
        figura = go.Figure(data=[
            go.Bar(
                x=['Agilidad', 'Fuerza', 'Vigor'],
                y=[character.agility, character.strength, character.vigor],
                text=[character.agility, character.strength, character.vigor],
                textposition='auto',
            )
        ])
        figura.update_layout(
            title='Atributos del Personaje',
            yaxis_title='Valor',
            xaxis_title='Atributos',
            barmode='stack'
        )

        # Cálculo de VM actual
        vm_total_actual = float(character.movement_stats['Velocidad de Movimiento'])
        porcentaje_vm_actual = vm_total_actual / 3

        # Mejora sugerida
        mejoras = {}
        for stat in ['Fuerza', 'Vigor', 'Agilidad', 'Destreza', 'Voluntad', 'Conocimiento', 'Ingenio']:
            new_add_stats = add_stats.copy()
            new_add_stats[stat] = new_add_stats.get(stat, 0) + 1
            character_mejorado = CharacterStats(
                strength=atributos_base['Strength'],
                vigor=atributos_base['Vigor'],
                agility=atributos_base['Agility'],
                dexterity=atributos_base['Dexterity'],
                will=atributos_base['Will'],
                knowledge=atributos_base['Knowledge'],
                resourcefulness=atributos_base['Resourcefulness'],
                add_stats=new_add_stats,
                movement_add=movement_add,
                movement_bonus=movement_bonus,
                peso_arma=peso_arma,
                peso_armadura=peso_armadura
            )
            nueva_vm = float(character_mejorado.movement_stats['Velocidad de Movimiento'])
            mejoras[stat] = nueva_vm - vm_total_actual

        mejoras_ordenadas = sorted(mejoras.items(), key=lambda x: x[1], reverse=True)

        mejora_texto = 'Mejores mejoras al siguiente punto:\n'
        for idx, (estadistica, valor_mejora) in enumerate(mejoras_ordenadas, 1):
            mejora_texto += f'{idx}. {estadistica} (+{valor_mejora:.2f} VM)\n'

        # Seleccionar el arma según la combinación seleccionada
        if combination_select == 'comb1':
            weapon_left = weapon1_left
            weapon_right = weapon1_right
        else:
            weapon_left = weapon2_left
            weapon_right = weapon2_right

        # Generar la sección de Primary Combo
        primary_combo_elements = []

        # Por simplicidad, consideramos solo el arma de la mano derecha si existe
        if weapon_right:
            selected_weapon = weapon_stats.get(weapon_right)
        elif weapon_left:
            selected_weapon = weapon_stats.get(weapon_left)
        else:
            selected_weapon = None

        if selected_weapon and combat_type == 'weapon':
            # Obtener los detalles del combo
            combo = selected_weapon.get('Combo', [])
            impact_zones = selected_weapon.get('Impact Zones', {})
            base_damage = selected_weapon.get('Daño Base', 0)

            # Crear una lista para almacenar las filas de ataques
            primary_combo_rows = []
            current_row = []

            for idx, attack in enumerate(combo):
                attack_num = idx + 1
                # Crear input para Impact Zone
                impact_zone_input = dcc.Input(
                    id={'type': 'impact_zone', 'index': idx},
                    type='number',
                    min=1, max=3, step=1,
                    value=1,  # Valor por defecto
                    style={'width': '60px', 'display': 'inline-block', 'marginLeft': '10px'}
                )

                # Obtener el valor de la Impact Zone
                impact_zone = 1  # Valor por defecto
                impact_zone_value = impact_zones.get(impact_zone, 1.0)

                # Calcular daño
                attack_multiplier = attack['Daño %']
                damage = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=False
                )
                damage_headshot = character.calculate_attack_damage(
                    base_damage, attack_multiplier, impact_zone_value, headshot=True
                )

                # Formatear el daño
                if 'show_headshot' in show_headshot:
                    display_damage = f"{damage_headshot:.2f}"
                else:
                    display_damage = f"{damage:.2f} (HS: {damage_headshot:.2f})"

                # Tiempos
                windup = attack['Windup']
                attack_time = attack['Attack']

                # Construir la información del ataque
                attack_info = html.Div([
                    html.Div([
                        html.Span(f'Ataque {attack_num}', style={'fontWeight': 'bold'}),
                        html.Span(' Impact Zone: ', style={'marginLeft': '10px'}),
                        impact_zone_input,
                    ], style={'display': 'flex', 'alignItems': 'center'}),
                    html.Div([
                        html.Span(f"Daño: {display_damage}", style={'fontSize': '16px', 'fontWeight': 'bold'}),
                    ], style={'marginTop': '5px'}),
                    html.Div([
                        html.Span(f"Windup: {windup} ms", style={'marginRight': '20px'}),
                        html.Span(f"Attack: {attack_time} ms"),
                    ], style={'marginTop': '5px'}),
                ], style={'border': '1px solid #ccc', 'padding': '10px', 'marginBottom': '10px'})

                # Añadir el ataque a la fila actual
                current_row.append(dbc.Col(attack_info, width=6))

                # Si tenemos dos ataques en la fila o es el último ataque, añadimos la fila a las filas principales
                if len(current_row) == 2 or idx == len(combo) - 1:
                    primary_combo_rows.append(dbc.Row(current_row, style={'marginBottom': '10px'}))
                    current_row = []

            # Asignar las filas al elemento principal
            primary_combo_elements = primary_combo_rows

        else:
            primary_combo_elements.append(html.P('No hay arma seleccionada o el tipo de combate es "Spell Combat".'))

        return (
            weapon1_left_options,
            weapon1_right_options,
            weapon2_left_options,
            weapon2_right_options,
            weapon1_left_disabled,
            weapon1_right_disabled,
            weapon2_left_disabled,
            weapon2_right_disabled,
            stats_rows,
            movement_data,
            defense_data,
            utility_data,
            figura,
            html.Strong(f'Velocidad de Movimiento Total: {vm_total_actual:.2f}'),
            html.Strong(f'Porcentaje de VM: {porcentaje_vm_actual:.2f}%'),
            mejora_texto,
            primary_combo_elements,
)

---
callbacks\__init__.py

# callbacks/__init__.py

from .callbacks import register_callbacks


---
components\layout.py

# components/layout.py

from dash import html, dcc
import dash_bootstrap_components as dbc
import dash_table
from data import class_stats, weapon_stats

def create_layout(app):
    layout = dbc.Container([
        dbc.Row([
            dbc.Col(html.H1('Calculadora de Estadísticas', className='text-center mb-4'), width=12)
        ]),

        dbc.Row([
            # Sección de Parámetros (izquierda)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Parámetros', className='card-title'),
                        # Selector de Clase
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Clase', html_for='input-clase'),
                                dcc.Dropdown(
                                    id='input-clase',
                                    options=[{'label': clase, 'value': clase} for clase in class_stats.keys()],
                                    value='Bárbaro'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Armas
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Arma Izquierda', html_for='weapon1_left'),
                                dcc.Dropdown(
                                    id='weapon1_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Arma Derecha', html_for='weapon1_right'),
                                dcc.Dropdown(
                                    id='weapon1_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Selección de Segunda Arma (Opcional)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Segunda Arma Izquierda', html_for='weapon2_left'),
                                dcc.Dropdown(
                                    id='weapon2_left',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                            dbc.Col([
                                dbc.Label('Segunda Arma Derecha', html_for='weapon2_right'),
                                dcc.Dropdown(
                                    id='weapon2_right',
                                    options=[{'label': w['Nombre'], 'value': w['Nombre']} for w in weapon_stats.values()],
                                    value=None,
                                    disabled=False
                                ),
                            ]),
                        ], className='mb-3'),
                        # Campo para Daño Actual (visible condicionalmente)
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Daño Actual (solo para Zweihander)', html_for='current_damage_zweihander'),
                                dcc.Input(
                                    id='current_damage_zweihander',
                                    type='number',
                                    min=weapon_stats['Zweihander']['Daño Mínimo'],
                                    max=weapon_stats['Zweihander']['Daño Máximo'],
                                    step=1,
                                    placeholder='Introduce el daño actual',
                                    disabled=True
                                ),
                            ])
                        ], className='mb-3', id='damage_input_container'),
                        # Selección de Tipo de Combate
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Tipo de Combate', html_for='combat_type'),
                                dcc.Dropdown(
                                    id='combat_type',
                                    options=[
                                        {'label': 'Arma', 'value': 'weapon'},
                                        {'label': 'Magia', 'value': 'magic'},
                                        {'label': 'Mixto', 'value': 'mixed'},
                                    ],
                                    value='weapon'
                                ),
                            ])
                        ], className='mb-3'),
                        # Selección de Combinación
                        dbc.Row([
                            dbc.Col([
                                dbc.Label('Combinación de Ataques', html_for='combination_select'),
                                dcc.Dropdown(
                                    id='combination_select',
                                    options=[
                                        {'label': 'Combinación 1', 'value': 'comb1'},
                                        {'label': 'Combinación 2', 'value': 'comb2'},
                                        {'label': 'Combinación 3', 'value': 'comb3'},
                                    ],
                                    value='comb1'
                                ),
                            ])
                        ], className='mb-3'),
                        # Opción de Headshot
                        dbc.Row([
                            dbc.Col([
                                dbc.Checklist(
                                    options=[
                                        {"label": "Mostrar Headshot", "value": 'headshot'}
                                    ],
                                    value=[],
                                    id="show_headshot",
                                    switch=True,
                                ),
                            ])
                        ], className='mb-3'),
                        # Tablas de Estadísticas
                        dash_table.DataTable(
                            id='stats-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Movimiento', className='mt-3'),
                        dash_table.DataTable(
                            id='movement-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                                {'name': 'Bonus', 'id': 'Bonus', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Defensa', className='mt-3'),
                        dash_table.DataTable(
                            id='defense-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        html.Hr(),
                        html.H5('Utilidad', className='mt-3'),
                        dash_table.DataTable(
                            id='utility-table',
                            columns=[
                                {'name': 'Estadística', 'id': 'Estadística', 'type': 'text'},
                                {'name': 'Valor', 'id': 'Valor', 'type': 'numeric', 'editable': False},
                                {'name': 'Add', 'id': 'Add', 'type': 'numeric', 'editable': True},
                            ],
                            data=[],
                            style_cell={'textAlign': 'left', 'padding': '5px'},
                            style_header={'fontWeight': 'bold'},
                            style_table={'overflowY': 'auto'},
                        ),
                        # Resto de los componentes...
                    ]),
                ], className='mb-4'),
            ], width=4),

            # Sección de Resultados (derecha)
            dbc.Col([
                dbc.Card([
                    dbc.CardBody([
                        html.H4('Resultados', className='card-title'),
                        dcc.Graph(id='grafica-vm'),
                        html.Div(id='output-vm-total', className='mt-3'),
                        html.Div(id='output-porcentaje-vm', className='mt-2'),
                        html.H5('Mejoras Sugeridas', className='mt-4'),
                        html.Pre(id='output-mejora-optima', style={'whiteSpace': 'pre-wrap'}),
                        # Resumen del Combo y Daño
                        dbc.Row([
                            dbc.Col([
                                html.Div(id='primary_combo'),
                            ], width=6),
                            dbc.Col([
                                html.Div(id='damage_summary'),
                            ], width=6, style={'textAlign': 'right'}),
                        ], className='mt-3'),
                    ]),
                ]),
            ], width=8),
        ]),

    ], fluid=True)

    return layout

---
components\__init__.py

# components/__init__.py

from .layout import create_layout


---
data\class_stats.py

# data/class_stats.py

class_stats = {
    'Bárbaro': {
        'Strength': 20,
        'Vigor': 25,
        'Agility': 13,
        'Dexterity': 12,
        'Will': 18,
        'Knowledge': 5,
        'Resourcefulness': 12,
        'Health': 132.5,
        'Move Speed': 300,
    },
    'Pícaro': {
        'Strength': 15,
        'Vigor': 20,
        'Agility': 25,
        'Dexterity': 18,
        'Will': 12,
        'Knowledge': 8,
        'Resourcefulness': 14,
        'Health': 120,
        'Move Speed': 300,
    },
    # Añade más clases según sea necesario
}


---
data\weapon_stats.py

# data/weapon_stats.py

weapon_stats = {
    'Bare Hands': {
        'Nombre': 'Bare Hands',
        'Tipo': 'Unarmed',
        'Manos': 0,
        'Daño Mínimo': 10,
        'Daño Máximo': 10,
        'Peso': 0,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 200},
        ],
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.8,  # Mango
        },
    },
    'Arming Sword': {
        'Nombre': 'Arming Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 29,
        'Daño Máximo': 41,
        'Peso': 3,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 400, 'Attack': 205},
            {'Daño %': 1.05, 'Windup': 634, 'Attack': 157},
            {'Daño %': 1.10, 'Windup': 976, 'Attack': 154},
        ],
        'Recover': 1213,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Crystal Sword': {
        'Nombre': 'Crystal Sword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 550, 'Attack': 168},
            {'Daño %': 1.05, 'Windup': 147, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 107, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 330, 'Attack': 167},
        ],
        'Recover': 1068,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.65, # Mango
        },
    },
    'Falchion': {
        'Nombre': 'Falchion',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 30,
        'Daño Máximo': 40,
        'Daño Base': 35,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 680, 'Attack': 133},
            {'Daño %': 1.05, 'Windup': 1174, 'Attack': 127},
            {'Daño %': 1.10, 'Windup': 119, 'Attack': 172},
        ],
        'Recover': 1115,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.9,  # Parte media
            3: 0.75, # Mango
        },
    },
    'Longsword': {
        'Nombre': 'Longsword',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 34,
        'Daño Máximo': 44,
        'Daño Base': 39,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 930, 'Attack': 229},
            {'Daño %': 1.05, 'Windup': 906, 'Attack': 233},
            {'Daño %': 1.10, 'Windup': 977, 'Attack': 233},
        ],
        'Recover': 977,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    'Rapier': {
        'Nombre': 'Rapier',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 18,
        'Daño Máximo': 24,
        'Daño Base': 21,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 450, 'Attack': 56},
            {'Daño %': 1.05, 'Windup': 823, 'Attack': 79},
            {'Daño %': 1.10, 'Windup': 830, 'Attack': 81},
            {'Daño %': 1.15, 'Windup': 880, 'Attack': 83},
        ],
        'Recover': 688,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.88, # Parte media
            3: 0.75, # Mango
        },
    },
    'Short Sword': {
        'Nombre': 'Short Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 19,
        'Daño Máximo': 25,
        'Daño Base': 22,
        'Peso': 2,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 510, 'Attack': 121},
            {'Daño %': 1.05, 'Windup': 600, 'Attack': 133},
            {'Daño %': 1.10, 'Windup': 810, 'Attack': 172},
        ],
        'Recover': 813,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.75, # Mango
        },
    },
    'Viking Sword': {
        'Nombre': 'Viking Sword',
        'Tipo': 'Espada de una mano',
        'Manos': 1,
        'Daño Mínimo': 27,
        'Daño Máximo': 35,
        'Daño Base': 31,
        'Peso': 5,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 720, 'Attack': 165},
            {'Daño %': 1.05, 'Windup': 1011, 'Attack': 175},
            {'Daño %': 1.10, 'Windup': 1045, 'Attack': 145},
            {'Daño %': 1.15, 'Windup': 788, 'Attack': 175},
        ],
        'Recover': 788,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.85, # Parte media
            3: 0.7,  # Mango
        },
    },
    'Riposte': {
        'Nombre': 'Riposte',
        'Tipo': 'Ataque Especial',
        'Manos': 1,
        'Daño Mínimo': 22,
        'Daño Máximo': 28,
        'Daño Base': 25,
        'Peso': 4,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 1080, 'Attack': 260},
            {'Daño %': 1.05, 'Windup': 2690, 'Attack': 0},  # Recover sin ataque
        ],
        'Recover': 2690,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.7,  # Mango
        },
    },
    'Zweihander': {
        'Nombre': 'Zweihander',
        'Tipo': 'Espada de dos manos',
        'Manos': 2,
        'Daño Mínimo': 41,
        'Daño Máximo': 60,
        'Daño Base': 50,
        'Peso': 6,
        'Combo': [
            {'Daño %': 1.0, 'Windup': 990, 'Attack': 179},
            {'Daño %': 1.05, 'Windup': 1164, 'Attack': 200},
            {'Daño %': 1.10, 'Windup': 1537, 'Attack': 233},
        ],
        'Recover': 967,
        'Impact Zones': {
            1: 1.0,  # Extremo
            2: 0.8,  # Parte media
            3: 0.6,  # Mango
        },
    },
    # Añade más armas según sea necesario
}

---
data\__init__.py

# data/__init__.py

from .class_stats import class_stats
from .weapon_stats import weapon_stats


---
models\character.py

# models/character.py

class CharacterStats:
    def __init__(self, strength, vigor, agility, dexterity, will, knowledge, resourcefulness,
                 add_stats=None, bonus_stats=None,
                 movement_add=0, movement_bonus=0,
                 peso_arma=0, peso_armadura=0):
        self.strength = strength
        self.vigor = vigor
        self.agility = agility
        self.dexterity = dexterity
        self.will = will
        self.knowledge = knowledge
        self.resourcefulness = resourcefulness
        self.base_move_speed = 300  # Velocidad de movimiento base

        # Encantamientos de "Add" y "Bonus" para estadísticas principales
        self.add_stats = add_stats if add_stats else {}
        self.bonus_stats = bonus_stats if bonus_stats else {}

        # Encantamientos para Velocidad de Movimiento
        self.movement_add = movement_add
        self.movement_bonus = movement_bonus

        # Pesos
        self.peso_arma = peso_arma
        self.peso_armadura = peso_armadura

        self.apply_enchantments()
        self.calculate_stats()
        self.calculate_category_stats()

    def apply_enchantments(self):
        # Aplicar encantamientos de "Add" para estadísticas principales
        self.strength += self.add_stats.get('Fuerza', 0)
        self.vigor += self.add_stats.get('Vigor', 0)
        self.agility += self.add_stats.get('Agilidad', 0)
        self.dexterity += self.add_stats.get('Destreza', 0)
        self.will += self.add_stats.get('Voluntad', 0)
        self.knowledge += self.add_stats.get('Conocimiento', 0)
        self.resourcefulness += self.add_stats.get('Ingenio', 0)

    def calculate_stats(self):
        # Redondear atributos después de aplicar encantamientos
        self.strength = round(self.strength, 2)
        self.vigor = round(self.vigor, 2)
        self.agility = round(self.agility, 2)
        self.dexterity = round(self.dexterity, 2)
        self.will = round(self.will, 2)
        self.knowledge = round(self.knowledge, 2)
        self.resourcefulness = round(self.resourcefulness, 2)

        self.physical_power = self.strength
        self.base_health = self.calculate_base_health()
        self.action_speed = self.calculate_action_speed()
        self.move_speed_modifier = self.calculate_move_speed()

        # Calcular Move Speed Rating total
        # Penalización por peso de armadura se considera como Gear Move Speed negativo
        gear_move_speed = -self.calculate_armor_penalty()
        total_movement_add = self.movement_add + gear_move_speed

        # Move Speed Rating antes del Move Speed Bonus (%)
        self.total_move_speed = self.base_move_speed + self.move_speed_modifier + total_movement_add

        # Convertir a % Move Speed
        percent_move_speed = self.total_move_speed / 3

        # Añadir Move Speed Bonus (%)
        percent_move_speed += self.movement_bonus

        # Reconversión a Move Speed Rating
        self.total_move_speed = percent_move_speed * 3

        # Cap de Move Speed a 330 (110%)
        self.total_move_speed = min(self.total_move_speed, 330)

        # Asegurarnos de que la velocidad no sea negativa
        self.total_move_speed = max(0, round(self.total_move_speed, 2))

    def calculate_base_health(self):
        sum_stats = self.strength * 0.25 + self.vigor * 0.75
        if sum_stats <= 10:
            return 75 + 3 * sum_stats
        elif 10 < sum_stats <= 50:
            return 105 + 2 * (sum_stats - 10)
        elif 50 < sum_stats <= 75:
            return 185 + 1 * (sum_stats - 50)
        elif 75 < sum_stats <= 100:
            return 210 + 0.5 * (sum_stats - 75)
        else:
            return 222.5

    def calculate_action_speed(self):
        sum_stats = self.agility * 0.25 + self.dexterity * 0.75
        if sum_stats <= 10:
            return -38 + 3 * sum_stats
        elif 10 < sum_stats <= 13:
            return -8 + 2 * (sum_stats - 10)
        elif 13 < sum_stats <= 25:
            return -2 + 1 * (sum_stats - 13)
        elif 25 < sum_stats <= 41:
            return 10 + 1.5 * (sum_stats - 25)
        elif 41 < sum_stats <= 50:
            return 34 + 1 * (sum_stats - 41)
        elif 50 < sum_stats <= 100:
            return 43 + 0.5 * (sum_stats - 50)
        else:
            return 68

    def calculate_move_speed(self):
        if self.agility <= 0:
            return -10
        elif 0 < self.agility <= 10:
            return -10 + 0.5 * self.agility
        elif 10 < self.agility <= 15:
            return -5 + 1 * (self.agility - 10)
        elif 15 < self.agility <= 75:
            return 0 + 0.75 * (self.agility - 15)
        elif 75 < self.agility <= 100:
            return 45 + 0.5 * (self.agility - 75)
        else:
            return 57.5

    def calculate_armor_penalty(self):
        return self.peso_armadura * 1.0

    def calculate_category_stats(self):
        penalizacion_arma = self.peso_arma * 1.0
        velocidad_con_arma = self.total_move_speed - penalizacion_arma
        velocidad_con_arma = max(0, round(velocidad_con_arma, 2))  # No puede ser negativa

        # Movement
        self.movement_stats = {
            'Velocidad de Movimiento': f'{self.total_move_speed:.2f}',
            'Peso de arma': f'{self.peso_arma}',
            'Peso de armadura': f'{self.peso_armadura}',
            'Velocidad de movimiento con arma': f'{velocidad_con_arma:.2f}',
        }

        # Damage
        self.damage_stats = {
            'Bono de Poder Físico': f'{self.calculate_physical_power_bonus():.2f}%',
            'Poder Físico': f'{self.physical_power:.2f}',
            'Velocidad de Acción': f'{self.action_speed:.2f}%',
        }

        # Defense
        self.defense_stats = {
            'Salud Base': f'{self.base_health:.2f}'
        }

        # Utility
        self.utility_stats = {
            'Ingenio': f'{self.resourcefulness:.2f}'
        }

    def calculate_physical_power_bonus(self):
        if self.physical_power <= 5:
            bonus = -80 + 10 * self.physical_power
        elif 5 < self.physical_power <= 7:
            bonus = -30 + 5 * (self.physical_power - 5)
        elif 7 < self.physical_power <= 11:
            bonus = -20 + 3 * (self.physical_power - 7)
        elif 11 < self.physical_power <= 15:
            bonus = -8 + 2 * (self.physical_power - 11)
        elif 15 < self.physical_power <= 50:
            bonus = 0 + 1 * (self.physical_power - 15)
        elif 50 < self.physical_power <= 100:
            bonus = 35 + 0.5 * (self.physical_power - 50)
        else:
            return 60  # Máximo según la tabla
        return bonus

    def calculate_attack_damage(self, base_damage, attack_multiplier, impact_zone_multiplier, headshot=False):
        # Cálculo básico del daño
        damage = base_damage * attack_multiplier * impact_zone_multiplier
        # Aplicar bono de Poder Físico
        physical_power_bonus = self.calculate_physical_power_bonus() / 100
        damage *= (1 + physical_power_bonus)
        # Aplicar modificador de headshot si corresponde
        if headshot:
            damage *= 1.5  # Supongamos que el headshot multiplica el daño por 1.5
        return damage

    def set_weapon_damage(self, weapon_name, current_damage):
        weapon = weapon_stats.get(weapon_name)
        if not weapon:
            raise ValueError("Arma no encontrada.")
        
        min_damage = weapon.get('Daño Mínimo', weapon.get('Daño Base'))
        max_damage = weapon.get('Daño Máximo', weapon.get('Daño Base'))
        
        if not (min_damage <= current_damage <= max_damage):
            raise ValueError(f"El daño debe estar entre {min_damage} y {max_damage} para {weapon_name}.")

        self.current_weapon_damage = current_damage


---
models\__init__.py

# models/__init__.py

from .character import CharacterStats


---